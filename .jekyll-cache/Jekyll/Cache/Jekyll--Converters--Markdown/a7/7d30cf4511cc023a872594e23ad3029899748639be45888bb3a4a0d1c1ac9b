I"è<p>As I‚Äôve been researching devops, and improving development workflows in general, I‚Äôve heard about feature toggles over and over. So what are they, and what‚Äôs the point?</p>

<p>My first thought was that it just sounds like extra overhead when you‚Äôre just trying to get something done. But as I‚Äôve started to work with them more and more, I‚Äôve realized the amazing flexibility they can provide.</p>

<p>If you‚Äôve ever worked in a project with multiple developers in a single codebase, you‚Äôve probably experienced the pain of merging your work. We‚Äôve all been there. You make a git branch to work on a new feature, and even if you‚Äôve only been working on it for a day or two, another developer edits the same file‚Ä¶ and boom, you get a merge conflict. This gets even worse the longer your branch is alive.</p>

<p><strong>So, what makes them so great?</strong>
When I start working on a new feature, the first thing I do is create a toggle for it. The beauty of this is that I can merge work much sooner than the feature being complete. You can work on something safely in isolation, keep it integrated into <a href="https://en.wikipedia.org/wiki/Trunk_(software)">trunk</a>, and only enable it when you‚Äôre ready. Even a feature that takes multiple weeks to complete can be merged in much smaller, easier to handle pieces, and this makes everything easier. If you get a conflict at all, it‚Äôs much smaller and easier to deal with, and code reviews are only needed for smaller changesets.</p>

<p><strong>What about when you want the feature to be permanent?</strong>
How are you supposed to remove the toggle? This is where my recommendation would be that your implementation/ feature toggle library should use a concrete class, or something strongly typed. When you want to make a toggle permanent, we just find all the references to that class, remove the toggle code, then delete the class for that toggle. It‚Äôs clean, and easy.</p>

<p>Here‚Äôs a <em>very</em> simple example of what I mean. In real life, depending on the problem you‚Äôre working on, I would use dependency injection to inject different implementations instead of just sticking an if statement into the code like this.</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">public</span> <span class="k">interface</span> <span class="nc">IFeatureToggle</span> 
<span class="p">{</span>
  <span class="kt">bool</span> <span class="nf">ToggleEnabled</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">MyNewFeatureToggle</span> <span class="p">:</span> <span class="n">IFeatureToggle</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="kt">bool</span> <span class="nf">ToggleEnabled</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="c1">// this logic can work however you'd like. You can check a config file, sql server, etc.</span>
    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
  <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">var</span> <span class="n">newFeature</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MyNewFeatureToggle</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">newFeature</span><span class="p">.</span><span class="nf">ToggleEnabled</span><span class="p">())</span>
      <span class="nf">DoTheNewThing</span><span class="p">();</span>
    <span class="k">else</span>
      <span class="nf">DoTheOldThing</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">DoTheOldThing</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"doing the old thing"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">DoTheNewThing</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"doing the new thing"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h1 id="my-recommendations">My Recommendations:</h1>
<ul>
  <li>Don‚Äôt <em>just</em> use configuration files with magic strings, use concrete types for easier toggle removal in the future.</li>
  <li>Don‚Äôt make assumptions about toggle status, if your code expects a configuration value for a toggle that isn‚Äôt present, I like to throw an exception to fail early.</li>
  <li>Remove toggles when you know the feature is okay, this is tech debt, but once you get in the habit of doing this, the refactor isn‚Äôt too painful.</li>
  <li>If your application consists of many services as most do, I found it nice to have a toggle that works across all of them. For example, I‚Äôve worked on an application that consists of a .NET core api, a .NET full framework application, and an Angular 6 front end. If you can, write your toggle implementation in a way that can update all of them with a single configuration change. This way if you need to make front and backend changes, they can be flipped on and off at the same time.</li>
  <li>Do what works for you. If you don‚Äôt need something complicated, even a simple implementation can be a huge help. You can enhance it in the future if you want to start using these for things like A/B testing, etc.</li>
</ul>
:ET